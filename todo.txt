features:
=========
optional checksums
arq__send_wnd_init
arq__recv_wnd_init
hook the linear allocator up to the various data structures
ARQ_ERR_NEED_POLL
metrics on crc failures, bad frames (too long before cobs 0)

build / infra:
==============
pull out mock functions into common header
(compile-time selection?) only allow power-of-two-sized windows, replace div/mod
ninja builds should emit timing json into CMAKE_BINARY_DIR
compilation tests don't run by default?

hygiene:
========
hide __builtin_ctz() behind ARQ_COUNT_TRAILING_ZEROES()
unsigned everywhere, none of this stuff is ever legit negative
normalize naming: size is the size of a struct / header / whatever. len is the length of a buffer.
send_ptr_release() errors if the send pointer isn't owned by the user? new error enum?
better return values for send_ptr_get and send_ptr_release (you already have ptr, there's nothing to send, etc)
assert that the logical size of arq_t + buffers == the physical size (account for all padding)
pull out buf/cap/len into arq__buf_t, reuse for send/recv frame_t's

timers:
=======
send tinygram timer
inter-byte and intra-frame timers

correctness?
============
do we NAK sequence numbers off the top end of the recv window? or just ignore?
if send window receives a NAK, should reset send window pointer if NAK is < current pointer seq/seg

optimizations:
==============
ACK timers in the receive window in case final segment in message gets corrupted?
big bit vector to hold 'ready' message state of entire send window? rtx == 0 => msg bit set?
instead of % and / all over the place for indexing + iterating, use 2 loops: pre-wrap, post-wrap
maybe a builtin_expect in recv_frame_fill, 1/16 chance of terminator byte for empty frame
multiple frames can fit in the ingoing / outgoing frame buffers, exploit that
recv window ack flag array => bitfield? might not be much smaller / faster
